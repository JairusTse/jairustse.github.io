---
layout: post
title: TCP/IP协议族和HTTPS
category: android
tags: [android,HTTPS,TCP/IP]
---


TCP/IP协议族是一套网络通信的协议。其中TCP和IP协议是最重要的两个。

## 网络传输分层


![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310145818.png)


网络传输分为4层：
- 应用层：做具体事情的，有HTTP通信协议，FTP文件传输协议、DNS协议、SMTP邮件协议等；
- 传输层：有TCP和UDP两种传输协议；
- 网络层：有IP协议；
- 数据链路层：实际传输的物理线路，包括以太网、wifi、路由器等都属于数据链路层。



### TCP

TCP是一种**可靠的**、**有状态**的连接（通信双方认识并且记住对方）。

**TCP和UDP的区别：**
TCP会对数据进行**拆分**，接收到数据后进行**排序和组装**。而UDP则不会，UDP不支持对数据进行拆分和组装，也不保证**可靠性**，给数据添加一个UDP协议头，就交给网络层。网络层和数据链路层也会建立连接到接收方才能传输数据，但是UDP不关心这个连接，所以叫**面向无连接**。

**TCP连接的三次握手：**
![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310151730.png)



**TCP断开连接的四次挥手：**

![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310151915.png)


因为「发送方」通知「接受方」没有消息发的时候，「接收方」可能还有消息要发，所以需要四次挥手。


### Socket

Java中的`Socket`就是建立TCP连接的类。其中`InputStream`是接收消息，`OutputStream`是发送消息。


### 长链接

建立TCP连接后，双方可以一直通信，但是一直保持连接是比较消耗资源的，所以一段时间没有通信，连接会断开并释放资源。  

**为什么需要长链接？**
我们一般是通过层层内网的网关访问目标服务器的，一段时间没有通信，网关可能会把TCP连接断开，但是「主机1」和目标服务器的通信还没有结束，比如**聊天应用**或者**推送服务**。这时候就需要**长链接**。

![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310153445.png)


**怎样实现长链接？**
保持长链接的方法是**心跳**，即每隔一段时间发送一次无意义的消息，防止被运营商标记为空闲并释放。



## HTTPS

HTTPS不是一种协议，而是对HTTP进行TLS/SSL加密。


**HTTPS是在应用层和传输层之间增加了一层TLS（传输层安全协议）：**

![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310155921.png)



### HTTPS（TLS）加密原理：

**出于对安全和性能两方面的考虑：**
- 建立TLS连接是用非对称加密（安全）
- 建立TLS成功后，通信是用对称加密（性能好）


![](https://gitee.com/jairustes/blogimages/raw/master/img/20220310225439.png)


**建立TLS连接的几个关键步骤：**

**1. 证书验证身份**
- 证书是为了返回**服务器公钥**，并且证明「你是你」。这一步跟**安全**无关，公钥是公开的，只是证明这个公钥确实是所期待的服务器返回来的。
- 服务器有**证书签发机构**签发的证书，**证书签发机构**有**根证书**所签发的证书，**根证书**在操作系统的**钥匙串**里面。
- 客户端的**根证书**信任**证书签发机构**，**证书签发机构**信任它所签发过证书的所有**服务器**（合法性），服务器证书里面带有**Host**，对比确认是客户端发起请求的Host（一致性）。
- 验证证书是通过验证**签名**实现的。以**证书签发机构**验证**服务器**签名为例：「服务器证书」包含`服务器公钥`、`Host`等信息，**证书签发机构**对「服务器证书」进行**签名**（用私钥对「服务器证书」的Hash进行一次加密运算），把「服务器证书」、「签名」和「**证书签发机构**的公钥」发给**客户端**，进行验证（通过「**证书签发机构**的公钥」对「签名」解密后，跟「服务器证书」进行一次Hash计算得到的值比较是否一致）。


**2. 对称加密通信**

- 服务器公钥是为了对一个随机数加密（窃听者无法解密），然后客户端和服务端分别用这个随机数（还有其他值），用相同的算法计算得到对称密钥`Master Secret`(一套)；
- `Master Secret`包括：
    - 客户端密钥：客户端发消息和服务端发消息用不同的密钥，防止拦截者把消息回传给发送方。
    - 服务端密钥
    - 客户端 Mac Secret：带密码的Hash计算（同时有**指纹**（Hash）和**验证身份**（有密码的双方才能解密）功能）
    - 服务端 Mac Secret




